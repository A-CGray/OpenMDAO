
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<script type="text/javascript">
    <tabulator_src>
</script>
<script type="text/javascript">
        <d3_src>
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
    var data = <scaling_data>;
</script>
<style>
    <tabulator_style>
    div.tooltip {
        position: absolute;
        text-align: center;
        width: 80px;
        height: 28px;
        padding: 2px;
        font: 12px sans-serif;
        background: lightsteelblue;
        border: 0px;
        border-radius: 8px;
        pointer-events: none;
        opacity: 0;
    }

    /* Style the tab */
    .tab {
        overflow: hidden;
        border: 1px solid #ccc;
        background-color: #f1f1f1;
    }

    /* Style the buttons that are used to open the tab content */
    .tab button {
        background-color: inherit;
        float: left;
        border: none;
        outline: none;
        cursor: pointer;
        padding: 14px 16px;
        transition: 0.3s;
    }

    /* Change background color of buttons on hover */
    .tab button:hover {
      background-color: #ddd;
    }

    /* Create an active/current tablink class */
    .tab button.active {
      background-color: #ccc;
    }

    /* Style the tab content */
    .tabcontent {
        display: none;
        padding: 6px 12px;
        border: 1px solid #ccc;
        border-top: none;
    }

    .spacer {
        width: 100%;
        height: 30px;
    }

    #help-text {
        display: none;
    }
</style>
</head>
<body onload="startup()">

    <h2 id="scaling_title"></h2>
    <button id="help-button" onclick="toggleHelp(event)">Show help</button>
    <div id="help-text">
        <h2>Scaling Process</h2 >
        <p>All scaling in OpenMDAO results in the following linear transformation:</p>
        <p><em>Variable<sub>driver</sub> = m * Variable<sub>model</sub> + b</em></p>
        <p>The computed values for <em>m</em> and <em>b</em> depend on how you specify the scaling, and
            whether or not you specify units that the
            driver sees which are different from the units in the model.</p>
        <h3>If you use driver units</h3>
        <p>If your model variable is in units of <em>m</em> and you choose to use <em>cm</em> for the driver value then you have a unit_factor of
        100. This conversion is done before anything else. All other scaling is done relative to the driver unit values. If your
        model value was 5.2 meters, then the driver value is 520 centimeters. You would then give ref and ref0 or scaler and adder
        relative to that.</p>
        <p>In general, unit conversions can include both a multiplicative factor and an offset (thank you, Celsius to Fahrenheit).</p>
        <p>Given a variable from the model (<em>x<sub>model</sub></em>), the unit converted value (<em>x<sub>driver</sub></em>) is computed by</p>
        <p><em>x<sub>driver</sub> = unit_factor * (x<sub>model</sub> + offset)</em></p>
        <h3>If you use ref and ref0:</h3>
        <p>The ref and ref0 values represent the model values that will get scaled to 1 and 0 respectively.</p>
        <p><em>1 = m * (ref + b)<br>0 = m * (ref0 + b)</em></p>
        <p>This gives the following for <em>m</em> and <em>b</em>:</p>
        <p><em>b = -ref0<br>m = 1/(ref - ref0)</em></p>
        <h3>If you use scaler and adder:</h3>
        <p>You are specifying the slope and offset for the scaling directly.</p>
        <p><em>b = adder<br>m = scaler</em></p>
        <h3>Full unit scaling equation</h3>
        <p>All of the scaling combined gives a linear map between the driver scaled value (<em>x<sub>driver</sub></em>),
            the unit scaled value, and the actual model value (<em>x<sub>model</sub></em>).</p>
        <p><em>x<sub>driver</sub> = m * (unit_factor * (x<sub>model</sub> + offset) + b)</em></p>
        <p><em>x<sub>driver</sub> = (m * unit_factor) * (x<sub>model</sub> + offset + b/unit_factor)</em></p>
        <p>So the overall scaler is (<em>m * unit_factor</em>) and the overall adder is
            (<em>offset + b/unit_factor</em>).</p>
    </div>
    <h3>Design Variables</h3>
    <div id="dv-table"></div>
    <h3>Constraints</h3>
    <div id="con-table"></div>
    <h3>Objectives</h3>
    <div id="obj-table"></div>
    <div class="spacer"></div>
    <div class="tab">
        <button id="varjac-button" class="tablinks" onclick="openJac(event, '#variable-tab')">Sensitivity by Variable</button>
        <button id="subjac-button" class="tablinks" onclick="openJac(event, '#entry-tab')">Sensitivity by Entry</button>
    </div>
    <div id="variable-tab" class="tabcontent">
        <div id="norm-jac">
            <svg id="norm-svg" class="heatmap">
            </svg>
        </div>
    </div>

    <div id="entry-tab" class="tabcontent">
        <div id="sub-jac">
            <h3 id="sub-jac-title"></h3>
            <svg class="heatmap">
            </svg>
        </div>
    </div>
    <div class="tooltip"></div>

<script type="text/javascript">

var dv_tabledata = data.dv_table;
var con_tabledata = data.con_table;
var obj_tabledata = data.obj_table;
var wrtVars = data.wrtlabels;
var ofVars = data.oflabels;

document.title = data.title;
document.getElementById("scaling_title").innerHTML = data.title

var d3_format = d3.format(".6~g");

var arr_format = function(num) {
    return "<b>&lt</b> " + d3_format(num) + " <b>&gt</b>";
}

var val_formatter = function(cell, formatterParams, onRendered) {
    // cell value is actually [value, size]
    let val = cell.getValue();
    if (val[1] > 1) {
        return arr_format(val[0]);
    }
    if (val[0] == "") {
        return "";
    }
    return d3_format(val[0]);
};


var val_sorter = function(a, b, aRow, bRow, column, dir, sorterParams) {
    if (a == "") {
        a = [-1e99, 0];
    }
    if (b == "") {
        b = [-1e99, 0];
    }
    return a[0] - b[0];
}


var numrow = function(title, field) {
    return {title:title, field:field, hozAlign:"right", visible:true, headerFilter:false, formatter:val_formatter, sorter:val_sorter}
}


var dvtable =
    new Tabulator("#dv-table", {
        // set height of table (in CSS or here), this enables the Virtual DOM and
        // improves render speed dramatically (can be any valid css height value)
        // height: 650,
        dataTree:true,
        dataTreeStartExpanded:false,
        data:dv_tabledata, //assign data to table
        layout:"fitDataFill", //"fitColumns", "fitDataFill",
        columns:[ //Define Table Columns
            {title: "name", field:"name", hozAlign:"left", headerFilter:false, visible:true,},
            {title: "size", field:"size", hozAlign:"center", headerFilter:false, visible:true,},
            {title: "index", field:"index", hozAlign:"center", headerFilter:false, visible:true,},
            {title: "Driver", headerHozAlign: "center", columns: [
                numrow("value", "driver_val"),
                {title: "units", field:"driver_units", hozAlign:"center", headerFilter:false, visible:true, headerSort:false,},
            ]},
            {title: "Model", headerHozAlign: "center", columns: [
                numrow("value", "model_val"),
                {title: "units", field:"model_units", hozAlign:"center", headerFilter:false, visible:true, headerSort:false,},
            ]},
            numrow("ref", "ref"),
            numrow("ref0", "ref0"),
            numrow("scaler", "scaler"),
            numrow("adder", "adder"),
            numrow("upper", "upper"),
            numrow("lower", "lower"),
        ],
    });


var contable =
    new Tabulator("#con-table", {
        // set height of table (in CSS or here), this enables the Virtual DOM and
        // improves render speed dramatically (can be any valid css height value)
        // height: 650,
        dataTree:true,
        dataTreeStartExpanded:false,
        data:con_tabledata, //assign data to table
        layout:"fitDataFill", //"fitColumns", "fitDataFill",
        columns: [ //Define Table Columns
            {title: "name", field:"name", hozAlign:"left", headerFilter:false, visible:true,},
            {title: "size", field:"size", hozAlign:"center", headerFilter:false, visible:true,},
            {title: "index", field:"index", hozAlign:"center", headerFilter:false, visible:true,},
            {title: "Driver", headerHozAlign: "center", columns: [
                numrow("value", "driver_val"),
                {title: "units", field:"driver_units", hozAlign:"center", headerFilter:false, visible:true, headerSort:false,},
            ]},
            {title: "Model", headerHozAlign: "center", columns: [
                numrow("value", "model_val"),
                {title: "units", field:"model_units", hozAlign:"center", headerFilter:false, visible:true, headerSort:false,},
            ]},
            numrow("ref", "ref"),
            numrow("ref0", "ref0"),
            numrow("scaler", "scaler"),
            numrow("adder", "adder"),
            numrow("upper", "upper"),
            numrow("lower", "lower"),
            numrow("equals", "equals"),
            {title: "linear", field:"linear", hozAlign:"center", visible:true, formatter:"tickCross",
            formatterParams: {
                crossElement: false,  // gets rid of 'x' elements so only check marks show
            }, headerFilter:false,},
        ],
    });


var objtable =
    new Tabulator("#obj-table", {
        // set height of table (in CSS or here), this enables the Virtual DOM and
        // improves render speed dramatically (can be any valid css height value)
        // height: 650,
        dataTree:true,
        dataTreeStartExpanded:false,
        data:obj_tabledata, //assign data to table
        layout:"fitColumns", //"fitDataFill",
        columns:[ //Define Table Columns
            {title: "name", field:"name", hozAlign:"left", visible:true, headerFilter:false,},
            {title: "size", field:"size", hozAlign:"center", visible:true, headerFilter:false,},
            {title: "index", field:"index", hozAlign:"center", headerFilter:false, visible:true,},
            {title: "Driver", headerHozAlign: "center", columns: [
                numrow("value", "driver_val"),
                {title: "units", field:"driver_units", hozAlign:"center", headerFilter:false, visible:true,headerSort:false,},
            ]},
            {title: "Model", headerHozAlign: "center", columns: [
                numrow("value", "model_val"),
                {title: "units", field:"model_units", hozAlign:"center", headerFilter:false, visible:true, headerSort:false,},
            ]},
            numrow("ref", "ref"),
            numrow("ref0", "ref0"),
            numrow("scaler", "scaler"),
            numrow("adder", "adder"),
        ],
    });


var mouseover = function(event, d) {
    event.stopPropagation();
    if (d[2] == null) return;
    tooltip.style("opacity", 1);
    d3.select(this).style("stroke", "black");
}

var mousemove = function(event, d) {
    event.stopPropagation();
    if (d[2] == null) return;
    var txt = d3_format(d[2]);
    var tshape = textSize(txt, 0);
    tooltip
        .attr("width", tshape.width + "px")
        .attr("height", tshape.height + "px")
        .html(txt)
        .style("left", event.pageX + 10 + "px")
        .style("top", event.pageY - 15 + "px");
}

var mouseleave = function(event, d) {
    event.stopPropagation();
    if (d[2] == null) return;
    tooltip.style("opacity", 0)
    d3.select(this).style("stroke", "none");
}


function toggleHelp(event) {
    let txt = d3.select("#help-text");
    if (txt.node().style.display === "block") {
        txt.style("display", "none");
    }
    else {
        txt.style("display", "block");
    }
}


function openSubjac(event, subdata) {
    // subdata: [ofname,  wrtname, value]  (value not used here)
    var ofslice = data.ofslices[subdata[0]];
    var wrtslice = data.wrtslices[subdata[1]];
    var filtered = data.mat_list.filter(function(d) {
        return d[0] >= ofslice[0] && d[0] < ofslice[1] && d[1] >= wrtslice[0] && d[1] < wrtslice[1];
    });
    var shifted = filtered.map(d => [d[0] - ofslice[0], d[1] - wrtslice[0], d[2]]);
    ynames = shifted.map(d => d[0].toString());
    xnames = shifted.map(d => d[1].toString());

    d3.select("#subjac-button").style("display", "block").node().click();
    d3.select("#subjac-button").html(subdata[0] + " <b>wrt</b> " + subdata[1])
    heatmap(ynames, xnames, shifted, "#sub-jac", false);
}


function openJac(evt, ident) {
    d3.selectAll(".tabcontent").style("display", "none");
    d3.selectAll(".tablinks").classed("active", false);
    d3.select(ident).style("display", "block");
    evt.currentTarget.className += " active";
}


function textSize(text, rotate) {
    var container = d3.select('body').append('svg');
    container.append('text')
        .attr("x", -99999)
        .attr("y", -99999)
        .attr("transform", "rotate(" + rotate + ")")
        .text(text);
    var bbox = container.node().getBBox();
    container.remove();
    return bbox;
}


function sizeOfLongest(strings, start, rotate) {
    var longest = strings.reduce((accum, val) => accum.length < val.length ? val : accum, start);
    return textSize(longest, rotate);
}


function expFormat(d) {
    return "1e" + d;
}

var heatmap = function heatmap(ofEntries, wrtEntries, jac_data, parent_id, addmouse) {
    var viewport_width = document.documentElement.clientWidth * .95;
    var viewport_height = document.documentElement.clientHeight * .95;

    var parent = d3.select(parent_id);
    var leftmargin = sizeOfLongest(ofEntries, "9999", 0).width;
    var bottommargin = sizeOfLongest(wrtEntries, "9999", 90).height;
    var legendwidth = 10;
    var legendloc = 20;

    // set the dimensions and margins of the graph
    var margin = {top: 30, right: 50 + legendloc + legendwidth, bottom: bottommargin, left: leftmargin };
    var width = viewport_width - margin.left - margin.right;
    var height = viewport_height - margin.top - margin.bottom;

    var heatmap = parent.select(".heatmap");
    heatmap.selectAll("g").remove();

    // append the svg object to the body of the page
    var svg = heatmap
        .attr("viewBox", "0 0 " + viewport_width + " " + viewport_height)
        .attr("preserveAspectRatio", "xMidYMid meet")
        .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Build X scales and axis:
    var x = d3.scaleBand()
        .range([0, width])
        .domain(wrtEntries)
        .padding(0.01);

    svg.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x))
            .selectAll("text")
            .style("text-anchor", "start")
            .attr("dx", ".8em")
            .attr("dy", "-.5em")
            .attr("transform", "rotate(90)");

    // Build Y scales and axis:
    var y = d3.scaleBand()
        .range([0, height])
        .domain(ofEntries)
        .padding(0.01);

    svg.append("g")
        .call(d3.axisLeft(y));

    svg.selectAll()
        .data(jac_data, d => d[1] + ':' + d[0])
        .enter()
        .append("rect")
        .attr("x", d => x(d[1]))
        .attr("y", d => y(d[0]))
        .attr("width", x.bandwidth())
        .attr("height", y.bandwidth())
        .style("fill", d => d[2] == null ? "gray" : subjacColor(d[2]))
        .on("mouseover", mouseover)
        .on("mousemove", mousemove)
        .on("mouseleave", mouseleave)
        .filter(d => addmouse && d[2] != null)  // don't add mouse handling to 0 entries
        .on("click", openSubjac, this);

    // create the gradient
    var grad_data = [
        {"color": subjacColor(-maxcolor), "value": -maxcolor},
        {"color": subjacColor(0), "value": 0},
        {"color": subjacColor(maxcolor), "value": maxcolor},
    ];

    var grad_id = parent_id + "-lingrad";
    var defs = parent.select(".heatmap").append("defs");
    var grad = defs.append("linearGradient")
        .attr('x1', '0%')
        .attr('y1', '100%')
        .attr('x2', '0%')
        .attr('y2', '0%')
        .attr("id", grad_id);

    grad.selectAll("stop")
        .data(grad_data)
        .enter().append("stop")
        .attr("offset", d => ((d.value + maxcolor) / (2*maxcolor) * 100) + "%")
        .attr("stop-color", d => d.color);

    // create the legend
    var leg_axis = d3.scaleLinear()
        .domain([maxcolor, -maxcolor])
        .range([0, height])
        .nice();

    var legend = parent.select(".heatmap")
        .append("g")
        .attr("transform", "translate(" + (margin.left + width) + "," + margin.top + ")");

    legend.append("g")
        .attr("transform", "translate(" + (legendwidth + legendloc + 3) + "," + 0 + ")")
        .call(d3.axisRight(leg_axis).tickFormat(expFormat));

    legend.append("rect")
            .attr("x", legendloc)
            .attr("width", legendwidth)
            .attr("height", height)
            .style("fill", "url(#" + grad_id + ")");
}

// create a tooltip
var tooltip = d3.select(".tooltip")
    .style("opacity", 0);

var maxcolor = d3.max(data.var_mat_list, s => s == null ? 0 : Math.abs(s[2]));

// Build color scale
var subjacColor = d3.scaleDiverging()
    .interpolator(d3.interpolateRdYlBu)
    .domain([-maxcolor, 0, maxcolor]);

heatmap(ofVars, wrtVars, data.var_mat_list, "#norm-jac", true);

function startup() {
    d3.select("#varjac-button").node().click();
    d3.select("#subjac-button").style("display", "none");
}

</script>
</body>
</html>
